#include <iostream>
#include <string>
#include <vector>
#include <unordered_set>
#include <cctype>
#include <iomanip>
using namespace std;

enum class TipoToken {
    PALABRA_RESERVADA, IDENTIFICADOR, ENTERO, DECIMAL,
    CADENA, SIMBOLO, DESCONOCIDO, FIN_ARCHIVO
};

string tipoAString(TipoToken t) {
    switch (t) {
        case TipoToken::PALABRA_RESERVADA: return "PalRes";
        case TipoToken::IDENTIFICADOR:     return "ID";
        case TipoToken::ENTERO:            return "Entero";
        case TipoToken::DECIMAL:           return "Decimal";
        case TipoToken::CADENA:            return "Cadena";
        case TipoToken::SIMBOLO:           return "Sim";
        case TipoToken::DESCONOCIDO:       return "ERROR";
        case TipoToken::FIN_ARCHIVO:       return "EOF";
        default:                           return "?";
    }
}

struct Token {
    string    lexema;
    TipoToken tipo;
    int       columna;
    int       renglon;
};

const unordered_set<string> PALABRAS_RESERVADAS = {
    "programa", "inicio", "fin", "var", "const",
    "si", "entonces", "sino", "mientras", "hacer",
    "contar", "desde", "hasta",
    "entero", "real", "cadena", "booleano",
    "verdadero", "falso", "leer", "escribir", "limpiar"
};

const unordered_set<string> SIMBOLOS_DOBLES = { ">=", "<=", "==", "!=" };
const unordered_set<char>   SIMBOLOS_SIMPLES = {
    '+', '-', '*', '/', '=', '>', '<',
    '(', ')', '[', ']', '{', '}',
    ';', ':', ',', '"', '!'
};

class AnalizadorLexico {
private:
    string fuente;
    size_t pos;
    int    renglon, columna;

    char actual()    { return pos < fuente.size() ? fuente[pos]         : '\0'; }
    char siguiente() { return pos + 1 < fuente.size() ? fuente[pos + 1] : '\0'; }

    void avanzar() {
        if (pos < fuente.size()) {
            if (fuente[pos] == '\n') { renglon++; columna = 1; }
            else columna++;
            pos++;
        }
    }

    void saltarEspacios() {
        while (pos < fuente.size() && isspace((unsigned char)actual())) avanzar();
        if (actual() == '/' && siguiente() == '/') {
            while (pos < fuente.size() && actual() != '\n') avanzar();
            saltarEspacios();
        }
    }

    Token leerIdentificador() {
        int col = columna, ren = renglon;
        string lex;
        while (pos < fuente.size() &&
               (isalpha((unsigned char)actual()) ||
                isdigit((unsigned char)actual()) || actual() == '_')) {
            lex += actual(); avanzar();
        }
        TipoToken tipo = PALABRAS_RESERVADAS.count(lex)
                         ? TipoToken::PALABRA_RESERVADA
                         : TipoToken::IDENTIFICADOR;
        return { lex, tipo, col, ren };
    }

    Token leerNumero() {
        int col = columna, ren = renglon;
        string lex;
        if ((actual() == '+' || actual() == '-') && isdigit((unsigned char)siguiente())) {
            if (tokens.empty() ||
                tokens.back().tipo == TipoToken::SIMBOLO ||
                tokens.back().tipo == TipoToken::PALABRA_RESERVADA) {
                lex += actual(); avanzar();
            }
        }
        while (pos < fuente.size() && isdigit((unsigned char)actual())) {
            lex += actual(); avanzar();
        }
        if (actual() == '.' && isdigit((unsigned char)siguiente())) {
            lex += actual(); avanzar();
            while (pos < fuente.size() && isdigit((unsigned char)actual())) {
                lex += actual(); avanzar();
            }
            return { lex, TipoToken::DECIMAL, col, ren };
        }
        return { lex, TipoToken::ENTERO, col, ren };
    }

    Token leerCadena() {
        int col = columna, ren = renglon;
        string lex = "\"";
        avanzar();
        bool cerrada = false;
        while (pos < fuente.size()) {
            char c = actual();
            if (c == '\n') break;
            if (c == '"') { lex += c; avanzar(); cerrada = true; break; }
            lex += c; avanzar();
        }
        if (!cerrada) {
            errores.push_back("Error: Cadena no cerrada en Col " +
                              to_string(col) + ", Ren " + to_string(ren));
            return { lex, TipoToken::DESCONOCIDO, col, ren };
        }
        return { lex, TipoToken::CADENA, col, ren };
    }

    Token leerSimbolo() {
        int col = columna, ren = renglon;
        string doble;
        doble += actual();
        if (siguiente() != '\0') doble += siguiente();
        if (SIMBOLOS_DOBLES.count(doble)) {
            avanzar(); avanzar();
            return { doble, TipoToken::SIMBOLO, col, ren };
        }
        if (actual() == '!' && siguiente() != '=') {
            string lex(1, actual());
            errores.push_back("Error: Simbolo '" + lex + "' no valido en Col " +
                              to_string(col) + ", Ren " + to_string(ren));
            avanzar();
            return { lex, TipoToken::DESCONOCIDO, col, ren };
        }
        string simple(1, actual()); avanzar();
        return { simple, TipoToken::SIMBOLO, col, ren };
    }

public:
    vector<Token>  tokens;
    vector<string> errores;

    AnalizadorLexico(const string& codigo)
        : fuente(codigo), pos(0), renglon(1), columna(1) {}

    void analizar() {
        while (pos < fuente.size()) {
            saltarEspacios();
            if (pos >= fuente.size()) break;
            char c = actual();

            if      (isalpha((unsigned char)c))                                      tokens.push_back(leerIdentificador());
            else if (isdigit((unsigned char)c))                                      tokens.push_back(leerNumero());
            else if ((c == '+' || c == '-') && isdigit((unsigned char)siguiente()))  tokens.push_back(leerNumero());
            else if (c == '"')                                                        tokens.push_back(leerCadena());
            else if (SIMBOLOS_SIMPLES.count(c))                                      tokens.push_back(leerSimbolo());
            else {
                int col = columna, ren = renglon;
                string lex(1, c);
                errores.push_back("Error: Caracter no valido '" + lex +
                                  "' en Col " + to_string(col) + ", Ren " + to_string(ren));
                tokens.push_back({ lex, TipoToken::DESCONOCIDO, col, ren });
                avanzar();
            }
        }
        tokens.push_back({ "EOF", TipoToken::FIN_ARCHIVO, columna, renglon });
    }
};

void imprimirTabla(const vector<Token>& tokens) {
    cout << "\nTABLA DE TOKENS\n";
    cout << string(51, '-') << "\n";
    cout << left
         << setw(20) << "Lexema"
         << setw(15) << "Tipo"
         << setw(8)  << "Col"
         << setw(8)  << "Renglon"
         << "\n";
    cout << string(51, '-') << "\n";
    for (const auto& t : tokens) {
        if (t.tipo == TipoToken::FIN_ARCHIVO) break;
        cout << left
             << setw(20) << t.lexema
             << setw(15) << tipoAString(t.tipo)
             << setw(8)  << t.columna
             << setw(8)  << t.renglon
             << "\n";
    }
    cout << string(51, '-') << "\n";
}

void imprimirResumen(const vector<Token>& tokens, const vector<string>& errores) {
    int palRes = 0, ids = 0, nums = 0, cads = 0, sims = 0, errs = 0;
    for (const auto& t : tokens) {
        if (t.tipo == TipoToken::FIN_ARCHIVO) break;
        if      (t.tipo == TipoToken::PALABRA_RESERVADA)                       palRes++;
        else if (t.tipo == TipoToken::IDENTIFICADOR)                           ids++;
        else if (t.tipo == TipoToken::ENTERO || t.tipo == TipoToken::DECIMAL)  nums++;
        else if (t.tipo == TipoToken::CADENA)                                  cads++;
        else if (t.tipo == TipoToken::SIMBOLO)                                 sims++;
        else if (t.tipo == TipoToken::DESCONOCIDO)                             errs++;
    }
    cout << "\nRESUMEN\n";
    cout << "Palabras reservadas : " << palRes << "\n";
    cout << "Identificadores     : " << ids    << "\n";
    cout << "Numeros             : " << nums   << "\n";
    cout << "Cadenas             : " << cads   << "\n";
    cout << "Simbolos            : " << sims   << "\n";
    cout << "Tokens invalidos    : " << errs   << "\n";

    if (errores.empty()) {
        cout << "\n Programa valido. Sin errores lexicos\n";
    } else {
        cout << "\nERRORES LEXICOS\n";
        for (const auto& e : errores) cout << e << "\n";
    }
    cout << "\n";
}

int main() {
    #ifdef _WIN32
        system("chcp 65001 > nul");
    #endif

    cout << "ANALIZADOR LEXICO - PSEUDOCODIGO ESPANOL\n";
    cout << "Escribe fin para analizar | salir para cerrar\n\n";

    while (true) {
        string codigoCompleto, linea;
        int numLinea = 1;

        while (true) {
            cout << setw(3) << numLinea << " | ";
            getline(cin, linea);
            if (linea == "fin") break;
            if (linea == "salir") return 0;
            codigoCompleto += linea + "\n";
            numLinea++;
        }

        if (codigoCompleto.empty()) {
            cout << "No se ingreso codigo.\n\n";
            continue;
        }

        AnalizadorLexico lexico(codigoCompleto);
        lexico.analizar();
        imprimirTabla(lexico.tokens);
        imprimirResumen(lexico.tokens, lexico.errores);

        cout << "Analizar otro programa? (s/n): ";
        char resp; cin >> resp; cin.ignore();
        if (resp == 'n' || resp == 'N') break;
        cout << "\n";
    }
    return 0;
}
